OFT Logical Selection Model v2

Full Research-Grade Simulation Notebook

Requires: python-sat, numpy, scipy, matplotlib

--------------------------------------------

0. Setup

--------------------------------------------

pip install python-sat[pblib,aiger] numpy scipy matplotlib

import numpy as np import random import itertools import math import matplotlib.pyplot as plt from pysat.solvers import Glucose3

--------------------------------------------

1. Universe Generator (3-SAT)

--------------------------------------------

def random_3sat(n_vars, m_clauses): clauses = [] for _ in range(m_clauses): vars_ = random.sample(range(1, n_vars + 1), 3) clause = [] for v in vars_: sign = random.choice([True, False]) clause.append(v if sign else -v) clauses.append(clause) return clauses

--------------------------------------------

2. DPLL Consistency Check

--------------------------------------------

def dpll_sat(clauses): solver = Glucose3() for c in clauses: solver.add_clause(c) sat = solver.solve() model = solver.get_model() if sat else None solver.delete() return sat, model

--------------------------------------------

3. WalkSAT Sampler

--------------------------------------------

def walksat_sample(clauses, n_vars, max_flips=5000, samples=50): solutions = []

for _ in range(samples):
    assign = {i: random.choice([True, False]) for i in range(1, n_vars + 1)}

    for _ in range(max_flips):
        unsat = []
        for c in clauses:
            if not any((lit > 0 and assign[abs(lit)]) or
                       (lit < 0 and not assign[abs(lit)]) for lit in c):
                unsat.append(c)

        if not unsat:
            solutions.append(assign.copy())
            break

        clause = random.choice(unsat)
        var = abs(random.choice(clause))
        assign[var] = not assign[var]

return solutions

--------------------------------------------

4. Mutual Information Estimator

--------------------------------------------

def mutual_information(samples, A, B): if len(samples) < 5: return 0.0

joint = {}
pa = {}
pb = {}

for s in samples:
    a = tuple(s[i] for i in A)
    b = tuple(s[i] for i in B)
    joint[(a, b)] = joint.get((a, b), 0) + 1
    pa[a] = pa.get(a, 0) + 1
    pb[b] = pb.get(b, 0) + 1

total = len(samples)
I = 0.0

for (a, b), count in joint.items():
    p_ab = count / total
    p_a = pa[a] / total
    p_b = pb[b] / total
    I += p_ab * math.log(p_ab / (p_a * p_b + 1e-12) + 1e-12)

return I

--------------------------------------------

5. Φ_obs Computation

--------------------------------------------

def compute_phi(samples, n_vars, trials=10, subset_size=2): if len(samples) < 5: return 0.0

vars_ = list(range(1, n_vars + 1))
I_vals = []

for _ in range(trials):
    A = random.sample(vars_, subset_size)
    B = random.sample(vars_, subset_size)
    I_vals.append(mutual_information(samples, A, B))

return np.mean(I_vals)

--------------------------------------------

6. Fragility Measure

--------------------------------------------

def fragility(clauses, phi, n_vars): if len(clauses) < 2: return 0.0

drops = []
for i in range(min(5, len(clauses))):
    reduced = clauses[:i] + clauses[i+1:]
    sat, _ = dpll_sat(reduced)
    if not sat:
        drops.append(phi)
    else:
        samples = walksat_sample(reduced, n_vars, samples=20)
        phi_r = compute_phi(samples, n_vars)
        drops.append(abs(phi - phi_r))

return np.mean(drops)

--------------------------------------------

7. Stability Functional

--------------------------------------------

def stability(C, K, Phi, F, beta=np.log(2), gamma=1.0, delta=1e-2): return C - beta * K + gamma * Phi - delta * F

--------------------------------------------

8. Full Sweep Over Law Density

--------------------------------------------

def run_sweep(n_vars=20, alpha_vals=None, universes=10): if alpha_vals is None: alpha_vals = np.linspace(1.0, 6.0, 12)

results = []

for alpha in alpha_vals:
    M = int(alpha * n_vars)
    S_vals = []
    Phi_vals = []

    for _ in range(universes):
        clauses = random_3sat(n_vars, M)
        sat, _ = dpll_sat(clauses)

        if not sat:
            S_vals.append(-M)
            Phi_vals.append(0)
            continue

        samples = walksat_sample(clauses, n_vars, samples=30)
        Phi = compute_phi(samples, n_vars)
        F = fragility(clauses, Phi, n_vars)

        S = stability(1, M, Phi, F)

        S_vals.append(S)
        Phi_vals.append(Phi)

    results.append((alpha, np.mean(S_vals), np.mean(Phi_vals)))

return np.array(results)

--------------------------------------------

9. Run Experiment

--------------------------------------------

alpha_vals = np.linspace(1.0, 6.0, 10) data = run_sweep(n_vars=20, alpha_vals=alpha_vals, universes=5)

--------------------------------------------

10. Plot Results

--------------------------------------------

plt.figure() plt.plot(data[:,0], data[:,2]) plt.xlabel("Clause Density α = M/N") plt.ylabel("Mean Φ_obs (Mutual Information)") plt.title("Observer Capacity vs Law Density") plt.show()

plt.figure() plt.plot(data[:,0], data[:,1]) plt.xlabel("Clause Density α = M/N") plt.ylabel("Mean Stability E[S]") plt.title("Stability Flow in Law-Space") plt.show()

--------------------------------------------

11. Gradient Flow on α

--------------------------------------------

def gradient_flow(alpha_vals, E_vals, lr=0.1, steps=20): a = np.mean(alpha_vals) for _ in range(steps): idx = np.argmin(np.abs(alpha_vals - a)) grad = np.gradient(E_vals)[idx] a += lr * grad a = max(min(a, max(alpha_vals)), min(alpha_vals)) return a

alpha_star = gradient_flow(data[:,0], data[:,1]) print("Converged α* =", alpha_star)

--------------------------------------------

End of Notebook

--------------------------------------------
